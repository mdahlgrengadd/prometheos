{
  "bridge_init.py": "# Import components (will be loaded together by the TypeScript loader)\r\n# Classes will be available from previous executions in the same context\r\n\r\n# Create legacy instances (safely check if classes exist)\r\ntry:\r\n    desktop_api_legacy = DesktopAPILegacy()\r\n    events_legacy = EventsLegacy()\r\nexcept NameError as e:\r\n    print(f\"Warning: Some classes not available during initialization: {e}\")\r\n    desktop_api_legacy = None\r\n    events_legacy = None\r\n\r\n# Create the desktop module structure\r\n\r\n\r\nclass Desktop:\r\n    def __init__(self):\r\n        # Safely initialize API components\r\n        try:\r\n            self.api = DesktopAPI()\r\n        except NameError:\r\n            self.api = None\r\n            print(\"Warning: DesktopAPI not available\")\r\n\r\n        try:\r\n            self.events = Events()\r\n        except NameError:\r\n            self.events = None\r\n            print(\"Warning: Events not available\")\r\n\r\n        try:\r\n            self.mcp = MCPProtocol()\r\n        except NameError:\r\n            self.mcp = None\r\n            print(\"Warning: MCPProtocol not available\")\r\n\r\n        try:\r\n            self.comlink = ComlinkHelper()\r\n        except NameError:\r\n            self.comlink = None\r\n            print(\"Warning: ComlinkHelper not available\")\r\n\r\n        # Legacy access for backward compatibility\r\n        self.api_legacy = desktop_api_legacy\r\n        self.events_legacy = events_legacy\r\n\r\n\r\n# Make it available globally\r\ndesktop = Desktop()\r\n\r\n\r\ndef handle_desktop_api_response(message):\r\n    \"\"\"Handle responses from the main thread API\"\"\"\r\n    try:\r\n        if message.get('type') == 'desktop-api-response':\r\n            print(f\"Received API response: {message}\")\r\n            # Could store results in a promise-like structure here\r\n\r\n        elif message.get('type') == 'desktop-api-event':\r\n            # Handle event notifications\r\n            event_name = message.get('eventName')\r\n            data = message.get('data')\r\n\r\n            # Safely check for event callbacks\r\n            try:\r\n                if hasattr(DesktopAPILegacy, '_event_callbacks') and event_name in DesktopAPILegacy._event_callbacks:\r\n                    callback = DesktopAPILegacy._event_callbacks[event_name]\r\n                    callback(data)\r\n            except NameError:\r\n                print(\"Warning: DesktopAPILegacy not available for event handling\")\r\n\r\n        elif message.get('type') == 'mcp-protocol-response':\r\n            # Handle MCP protocol responses\r\n            print(f\"Received MCP protocol response: {message.get('message')}\")\r\n            # Could integrate with a promise system here\r\n\r\n    except Exception as e:\r\n        print(f\"Error handling API response: {e}\")\r\n\r\n\r\nprint(\"Hybrid Desktop API Bridge initialized in Python context\")\r\n",
  "comlink_helpers.py": "import js\r\nfrom pyodide.ffi import create_proxy, to_js\r\n\r\n\r\nclass ComlinkHelper:\r\n    \"\"\"Improved Comlink communication helper for Python\"\"\"\r\n\r\n    @staticmethod\r\n    def expose(obj, name=\"pythonExports\"):\r\n        \"\"\"Expose a Python object to JavaScript via Comlink\"\"\"\r\n        try:\r\n            js_proxy = create_proxy(obj)\r\n            # Make it available globally\r\n            js.globalThis[name] = js_proxy\r\n            print(f\"Exposed Python object as {name} via Comlink\")\r\n            return True\r\n        except Exception as e:\r\n            print(f\"Error exposing object: {e}\")\r\n            return False\r\n\r\n    @staticmethod\r\n    def get_proxy(name):\r\n        \"\"\"Get a JavaScript object/function via Comlink\"\"\"\r\n        try:\r\n            if hasattr(js.globalThis, name):\r\n                return getattr(js.globalThis, name)\r\n            print(f\"Object {name} not found in global scope\")\r\n            return None\r\n        except Exception as e:\r\n            print(f\"Error getting proxy: {e}\")\r\n            return None\r\n\r\n\r\n# ComlinkHelper class is now available globally\r\n# It will be attached to the desktop object when the desktop object is created in bridge_init.py\r\n\r\nprint(\"Python-Comlink integration enhanced\")\r\n",
  "desktop_api.py": "import js\r\nfrom pyodide.ffi import create_proxy, to_js, JsProxy\r\nimport json\r\nimport uuid\r\n\r\nprint(\"Starting Hybrid Desktop API bridge setup...\")\r\n\r\n# ----------------------------------------------------\r\n# 1. Desktop API Layer (Comlink - Ergonomic Interface)\r\n# ----------------------------------------------------\r\n\r\n\r\nclass DesktopAPI:\r\n    \"\"\"Python interface to PromethOS APIs using Comlink\"\"\"\r\n\r\n    @staticmethod\r\n    async def list_components():\r\n        \"\"\"List all available API components\"\"\"\r\n        try:\r\n            # Safely get Comlink bridge from globalThis\r\n            api_comlink = getattr(js.globalThis, 'desktop_api_comlink', None)\r\n            if api_comlink is None:\r\n                raise Exception(\"Comlink API bridge not available\")\r\n\r\n            # Direct call to the Comlink proxy\r\n            result = await api_comlink.listComponents()\r\n            return result.to_py()\r\n        except Exception as e:\r\n            print(f\"Error listing components via Comlink: {e}\")\r\n            # Fallback to postMessage (will be available from combined script)\r\n            # return desktop_api_legacy.list_components()\r\n            return {'success': False, 'error': 'Comlink bridge not available'}\r\n\r\n    @staticmethod\r\n    async def execute(component_id, action, params=None):\r\n        \"\"\"Execute an action on a component\"\"\"\r\n        try:\r\n            if params is None:\r\n                params = {}\r\n\r\n            # Safely get Comlink bridge from globalThis\r\n            api_comlink = getattr(js.globalThis, 'desktop_api_comlink', None)\r\n            if api_comlink is None:\r\n                raise Exception(\"Comlink API bridge not available\")\r\n\r\n            # Convert Python dict to JS object with proper conversion\r\n            js_params = to_js(params)\r\n\r\n            # Direct call that returns the actual result\r\n            result = await api_comlink.execute(component_id, action, js_params)\r\n            return result.to_py()\r\n        except Exception as e:\r\n            print(f\"Error executing {component_id}.{action} via Comlink: {e}\")\r\n            # Fallback to postMessage (will be available from combined script)\r\n            return {'success': False, 'error': 'Comlink bridge not available'}\r\n\r\n    @staticmethod\r\n    async def subscribe_event(event_name, callback):\r\n        \"\"\"Subscribe to EventBus events\"\"\"\r\n        try:\r\n            proxy_callback = create_proxy(callback)\r\n\r\n            # Safely get Comlink bridge from globalThis\r\n            api_comlink = getattr(js.globalThis, 'desktop_api_comlink', None)\r\n            if api_comlink is None:\r\n                raise Exception(\"Comlink API bridge not available\")\r\n\r\n            # Direct call to subscribe\r\n            unsubscribe = await api_comlink.subscribeEvent(event_name, proxy_callback)\r\n\r\n            # Convert the JS function to a Python callable\r\n            def python_unsubscribe():\r\n                try:\r\n                    unsubscribe()\r\n                    proxy_callback.destroy()\r\n                except Exception as e:\r\n                    print(f\"Error unsubscribing: {e}\")\r\n\r\n            return python_unsubscribe\r\n        except Exception as e:\r\n            print(f\"Error subscribing to event {event_name} via Comlink: {e}\")\r\n            # Fallback to postMessage (will be available from combined script)\r\n            return lambda: None\r\n",
  "desktop_api_legacy.py": "# ----------------------------------------------------\r\n# Legacy Desktop API (postMessage - Compatibility)\r\n# ----------------------------------------------------\r\n\r\nclass DesktopAPILegacy:\r\n    \"\"\"Python interface to PromethOS APIs using postMessage\"\"\"\r\n\r\n    @staticmethod\r\n    def list_components():\r\n        \"\"\"List all available API components\"\"\"\r\n        try:\r\n            from js import postMessage\r\n            request_id = str(uuid.uuid4())\r\n\r\n            # Convert Python dict to JS object using to_js\r\n            message = to_js({\r\n                'type': 'desktop-api-request',\r\n                'requestId': request_id,\r\n                'method': 'list_components'\r\n            })\r\n            # Send request to main thread via postMessage\r\n            postMessage(message)\r\n\r\n            print(f\"API request sent: list_components\")\r\n            return {'success': True, 'message': 'Request sent to main thread'}\r\n\r\n        except Exception as e:\r\n            print(f\"Error listing components: {e}\")\r\n            return {'success': False, 'error': str(e)}\r\n\r\n    @staticmethod\r\n    def execute(component_id, action, params=None):\r\n        \"\"\"Execute an action on a component\"\"\"\r\n        try:\r\n            if params is None:\r\n                params = {}\r\n\r\n            from js import postMessage\r\n            import uuid\r\n            request_id = str(uuid.uuid4())\r\n\r\n            # Convert Python dict to JS object using to_js, with proper nested conversion\r\n            message = to_js({\r\n                'type': 'desktop-api-request',\r\n                'requestId': request_id,\r\n                'method': 'execute_action',\r\n                'params': to_js({\r\n                    'componentId': component_id,\r\n                    'action': action,\r\n                    'params': to_js(params)\r\n                })\r\n            })\r\n\r\n            # Send request to main thread via postMessage\r\n            postMessage(message)\r\n\r\n            print(f\"Sent API request: {component_id}.{action}\")\r\n            return {'success': True, 'message': 'Request sent to main thread'}\r\n\r\n        except Exception as e:\r\n            print(f\"Error executing {component_id}.{action}: {e}\")\r\n            return {'success': False, 'error': str(e)}\r\n\r\n    @staticmethod\r\n    def subscribe_event(event_name, callback):\r\n        \"\"\"Subscribe to EventBus events\"\"\"\r\n        try:\r\n            proxy_callback = create_proxy(callback)\r\n\r\n            from js import postMessage\r\n            import uuid\r\n            request_id = str(uuid.uuid4())\r\n\r\n            # Store callback for later use\r\n            if not hasattr(DesktopAPILegacy, '_event_callbacks'):\r\n                DesktopAPILegacy._event_callbacks = {}\r\n            DesktopAPILegacy._event_callbacks[event_name] = proxy_callback\r\n\r\n            # Send subscription request via postMessage\r\n            message = to_js({\r\n                'type': 'desktop-api-request',\r\n                'requestId': request_id,\r\n                'method': 'subscribe_event',\r\n                'params': to_js({\r\n                    'eventName': event_name\r\n                })\r\n            })\r\n            postMessage(message)\r\n\r\n            def unsubscribe():\r\n                if hasattr(DesktopAPILegacy, '_event_callbacks') and event_name in DesktopAPILegacy._event_callbacks:\r\n                    del DesktopAPILegacy._event_callbacks[event_name]\r\n                    proxy_callback.destroy()\r\n                    # Could send unsubscribe message here if needed\r\n\r\n            return unsubscribe\r\n\r\n        except Exception as e:\r\n            print(f\"Error subscribing to event {event_name}: {e}\")\r\n            return lambda: None\r\n",
  "events.py": "# ----------------------------------------------------\r\n# Events System\r\n# ----------------------------------------------------\r\n\r\nclass Events:\r\n    \"\"\"EventBus integration\"\"\"\r\n\r\n    @staticmethod\r\n    async def emit(event_name, data=None):\r\n        \"\"\"Emit an event to the desktop EventBus\"\"\"\r\n        try:\r\n            # Safely get Comlink bridge from globalThis\r\n            api_comlink = getattr(js.globalThis, 'desktop_api_comlink', None)\r\n            if api_comlink is None:\r\n                raise Exception(\"Comlink API bridge not available\")\r\n\r\n            # Convert data for JS\r\n            js_data = to_js(data) if data is not None else None\r\n\r\n            # Direct call to emit\r\n            await api_comlink.emitEvent(event_name, js_data)\r\n            return {'success': True, 'message': f'Event {event_name} emitted'}\r\n        except Exception as e:\r\n            print(f\"Error emitting event {event_name} via Comlink: {e}\")\r\n            # Fallback to postMessage (will be available from combined script)\r\n            return {'success': False, 'error': 'Comlink bridge not available'}\r\n\r\n    @staticmethod\r\n    async def subscribe(event_name, callback):\r\n        \"\"\"Subscribe to desktop events\"\"\"\r\n        # Will reference DesktopAPI when combined\r\n        return None\r\n\r\n\r\nclass EventsLegacy:\r\n    \"\"\"EventBus integration via postMessage\"\"\"\r\n\r\n    @staticmethod\r\n    def emit(event_name, data=None):\r\n        \"\"\"Emit an event to the desktop EventBus\"\"\"\r\n        try:\r\n            from js import postMessage\r\n            import uuid\r\n            request_id = str(uuid.uuid4())\r\n\r\n            message = to_js({\r\n                'type': 'desktop-api-request',\r\n                'requestId': request_id,\r\n                'method': 'emit_event',\r\n                'params': to_js({\r\n                    'eventName': event_name,\r\n                    'data': to_js(data) if data is not None else None\r\n                })\r\n            })\r\n            postMessage(message)\r\n\r\n            return {'success': True, 'message': f'Event {event_name} emitted'}\r\n\r\n        except Exception as e:\r\n            print(f\"Error emitting event {event_name}: {e}\")\r\n            return {'success': False, 'error': str(e)}\r\n\r\n    @staticmethod\r\n    def subscribe(event_name, callback):\r\n        \"\"\"Subscribe to desktop events\"\"\"\r\n        # Will reference DesktopAPILegacy when combined\r\n        return lambda: None\r\n",
  "mcp_protocol.py": "# ----------------------------------------------------\r\n# MCP Protocol Layer (JSON-RPC 2.0 Interface)\r\n# ----------------------------------------------------\r\n\r\nclass MCPProtocol:\r\n    \"\"\"Python interface to MCP protocol (JSON-RPC 2.0)\"\"\"\r\n\r\n    @staticmethod\r\n    async def send(message):\r\n        \"\"\"Send a raw MCP protocol message (JSON-RPC 2.0 format)\"\"\"\r\n        try:\r\n            # Ensure message is properly formatted as JSON-RPC 2.0\r\n            if not isinstance(message, dict):\r\n                raise ValueError(\"Message must be a dictionary\")\r\n\r\n            if not message.get('jsonrpc') == '2.0':\r\n                message['jsonrpc'] = '2.0'\r\n\r\n            if 'id' not in message:\r\n                message['id'] = str(uuid.uuid4())\r\n\r\n            # Convert to JS object - use JSON serialization to avoid JsProxy issues\r\n            import json\r\n            js_message_json = json.dumps(message)\r\n\r\n            # Debug: Log the message being sent\r\n            print(f\"Sending MCP message: {message}\")\r\n            print(f\"JSON message: {js_message_json}\")\r\n\r\n            # Forward to MCP handler in worker via the exposed plugin instance\r\n            # Access the plugin instance from pyodide globals (use js.globalThis, not Python globals())\r\n            plugin_instance = js.globalThis._pyodide_plugin_instance\r\n            if plugin_instance is None:\r\n                raise Exception(\"Pyodide plugin instance not available\")\r\n\r\n            # Pass the JSON string instead of JsProxy\r\n            result = await plugin_instance.handleMCPProtocolMessage(js_message_json)\r\n\r\n            # Extract the actual response from the PythonResult wrapper\r\n            if hasattr(result, 'success') and result.success and hasattr(result, 'result'):\r\n                return result.result.to_py() if hasattr(result.result, 'to_py') else result.result\r\n            elif hasattr(result, 'error'):\r\n                return {'jsonrpc': '2.0', 'error': {'code': -32603, 'message': result.error}, 'id': message.get('id')}\r\n            else:\r\n                return {'jsonrpc': '2.0', 'error': {'code': -32603, 'message': 'Internal error'}, 'id': message.get('id')}\r\n\r\n        except Exception as e:\r\n            print(f\"Error sending MCP message: {e}\")\r\n            return {'jsonrpc': '2.0', 'error': {'code': -32603, 'message': str(e)}, 'id': message.get('id')}\r\n\r\n    @staticmethod\r\n    async def tools_list():\r\n        \"\"\"Get list of available tools via MCP protocol\"\"\"\r\n        message = {\r\n            'jsonrpc': '2.0',\r\n            'method': 'tools/list',\r\n            'id': str(uuid.uuid4())\r\n        }\r\n        return await MCPProtocol.send(message)\r\n\r\n    @staticmethod\r\n    async def tools_call(tool_name, arguments=None):\r\n        \"\"\"Call a tool via MCP protocol\"\"\"\r\n        if arguments is None:\r\n            arguments = {}\r\n\r\n        message = {\r\n            'jsonrpc': '2.0',\r\n            'method': 'tools/call',\r\n            'params': {\r\n                'name': tool_name,\r\n                'arguments': arguments\r\n            },\r\n            'id': str(uuid.uuid4())\r\n        }\r\n        return await MCPProtocol.send(message)\r\n\r\n    @staticmethod\r\n    async def resources_list():\r\n        \"\"\"List available resources via MCP protocol\"\"\"\r\n        message = {\r\n            'jsonrpc': '2.0',\r\n            'method': 'resources/list',\r\n            'id': str(uuid.uuid4())\r\n        }\r\n        return await MCPProtocol.send(message)\r\n"
}