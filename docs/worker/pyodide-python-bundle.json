{
  "bridge_init.py": "# Import components (will be loaded together by the TypeScript loader)\n# Classes will be available from previous executions in the same context\n\n# Create legacy instances (safely check if classes exist)\ntry:\n    desktop_api_legacy = DesktopAPILegacy()\n    events_legacy = EventsLegacy()\nexcept NameError as e:\n    print(f\"Warning: Some classes not available during initialization: {e}\")\n    desktop_api_legacy = None\n    events_legacy = None\n\n# Create the desktop module structure\n\n\nclass Desktop:\n    def __init__(self):\n        # Safely initialize API components\n        try:\n            self.api = DesktopAPI()\n        except NameError:\n            self.api = None\n            print(\"Warning: DesktopAPI not available\")\n\n        try:\n            self.events = Events()\n        except NameError:\n            self.events = None\n            print(\"Warning: Events not available\")\n\n        try:\n            self.mcp = MCPProtocol()\n        except NameError:\n            self.mcp = None\n            print(\"Warning: MCPProtocol not available\")\n\n        try:\n            self.comlink = ComlinkHelper()\n        except NameError:\n            self.comlink = None\n            print(\"Warning: ComlinkHelper not available\")\n\n        # Legacy access for backward compatibility\n        self.api_legacy = desktop_api_legacy\n        self.events_legacy = events_legacy\n\n\n# Make it available globally\ndesktop = Desktop()\n\n\ndef handle_desktop_api_response(message):\n    \"\"\"Handle responses from the main thread API\"\"\"\n    try:\n        if message.get('type') == 'desktop-api-response':\n            print(f\"Received API response: {message}\")\n            # Could store results in a promise-like structure here\n\n        elif message.get('type') == 'desktop-api-event':\n            # Handle event notifications\n            event_name = message.get('eventName')\n            data = message.get('data')\n\n            # Safely check for event callbacks\n            try:\n                if hasattr(DesktopAPILegacy, '_event_callbacks') and event_name in DesktopAPILegacy._event_callbacks:\n                    callback = DesktopAPILegacy._event_callbacks[event_name]\n                    callback(data)\n            except NameError:\n                print(\"Warning: DesktopAPILegacy not available for event handling\")\n\n        elif message.get('type') == 'mcp-protocol-response':\n            # Handle MCP protocol responses\n            print(f\"Received MCP protocol response: {message.get('message')}\")\n            # Could integrate with a promise system here\n\n    except Exception as e:\n        print(f\"Error handling API response: {e}\")\n\n\nprint(\"Hybrid Desktop API Bridge initialized in Python context\")\n",
  "comlink_helpers.py": "import js\nfrom pyodide.ffi import create_proxy, to_js\n\n\nclass ComlinkHelper:\n    \"\"\"Improved Comlink communication helper for Python\"\"\"\n\n    @staticmethod\n    def expose(obj, name=\"pythonExports\"):\n        \"\"\"Expose a Python object to JavaScript via Comlink\"\"\"\n        try:\n            js_proxy = create_proxy(obj)\n            # Make it available globally\n            js.globalThis[name] = js_proxy\n            print(f\"Exposed Python object as {name} via Comlink\")\n            return True\n        except Exception as e:\n            print(f\"Error exposing object: {e}\")\n            return False\n\n    @staticmethod\n    def get_proxy(name):\n        \"\"\"Get a JavaScript object/function via Comlink\"\"\"\n        try:\n            if hasattr(js.globalThis, name):\n                return getattr(js.globalThis, name)\n            print(f\"Object {name} not found in global scope\")\n            return None\n        except Exception as e:\n            print(f\"Error getting proxy: {e}\")\n            return None\n\n\n# ComlinkHelper class is now available globally\n# It will be attached to the desktop object when the desktop object is created in bridge_init.py\n\nprint(\"Python-Comlink integration enhanced\")\n",
  "desktop_api.py": "import js\nfrom pyodide.ffi import create_proxy, to_js, JsProxy\nimport json\nimport uuid\n\nprint(\"Starting Hybrid Desktop API bridge setup...\")\n\n# ----------------------------------------------------\n# 1. Desktop API Layer (Comlink - Ergonomic Interface)\n# ----------------------------------------------------\n\n\nclass DesktopAPI:\n    \"\"\"Python interface to PromethOS APIs using Comlink\"\"\"\n\n    @staticmethod\n    async def list_components():\n        \"\"\"List all available API components\"\"\"\n        try:\n            # Safely get Comlink bridge from globalThis\n            api_comlink = getattr(js.globalThis, 'desktop_api_comlink', None)\n            if api_comlink is None:\n                raise Exception(\"Comlink API bridge not available\")\n\n            # Direct call to the Comlink proxy\n            result = await api_comlink.listComponents()\n            return result.to_py()\n        except Exception as e:\n            print(f\"Error listing components via Comlink: {e}\")\n            # Fallback to postMessage (will be available from combined script)\n            # return desktop_api_legacy.list_components()\n            return {'success': False, 'error': 'Comlink bridge not available'}\n\n    @staticmethod\n    async def execute(component_id, action, params=None):\n        \"\"\"Execute an action on a component\"\"\"\n        try:\n            if params is None:\n                params = {}\n\n            # Safely get Comlink bridge from globalThis\n            api_comlink = getattr(js.globalThis, 'desktop_api_comlink', None)\n            if api_comlink is None:\n                raise Exception(\"Comlink API bridge not available\")\n\n            # Convert Python dict to JS object with proper conversion\n            js_params = to_js(params)\n\n            # Direct call that returns the actual result\n            result = await api_comlink.execute(component_id, action, js_params)\n            return result.to_py()\n        except Exception as e:\n            print(f\"Error executing {component_id}.{action} via Comlink: {e}\")\n            # Fallback to postMessage (will be available from combined script)\n            return {'success': False, 'error': 'Comlink bridge not available'}\n\n    @staticmethod\n    async def subscribe_event(event_name, callback):\n        \"\"\"Subscribe to EventBus events\"\"\"\n        try:\n            proxy_callback = create_proxy(callback)\n\n            # Safely get Comlink bridge from globalThis\n            api_comlink = getattr(js.globalThis, 'desktop_api_comlink', None)\n            if api_comlink is None:\n                raise Exception(\"Comlink API bridge not available\")\n\n            # Direct call to subscribe\n            unsubscribe = await api_comlink.subscribeEvent(event_name, proxy_callback)\n\n            # Convert the JS function to a Python callable\n            def python_unsubscribe():\n                try:\n                    unsubscribe()\n                    proxy_callback.destroy()\n                except Exception as e:\n                    print(f\"Error unsubscribing: {e}\")\n\n            return python_unsubscribe\n        except Exception as e:\n            print(f\"Error subscribing to event {event_name} via Comlink: {e}\")\n            # Fallback to postMessage (will be available from combined script)\n            return lambda: None\n",
  "desktop_api_legacy.py": "# ----------------------------------------------------\n# Legacy Desktop API (postMessage - Compatibility)\n# ----------------------------------------------------\n\nclass DesktopAPILegacy:\n    \"\"\"Python interface to PromethOS APIs using postMessage\"\"\"\n\n    @staticmethod\n    def list_components():\n        \"\"\"List all available API components\"\"\"\n        try:\n            from js import postMessage\n            request_id = str(uuid.uuid4())\n\n            # Convert Python dict to JS object using to_js\n            message = to_js({\n                'type': 'desktop-api-request',\n                'requestId': request_id,\n                'method': 'list_components'\n            })\n            # Send request to main thread via postMessage\n            postMessage(message)\n\n            print(f\"API request sent: list_components\")\n            return {'success': True, 'message': 'Request sent to main thread'}\n\n        except Exception as e:\n            print(f\"Error listing components: {e}\")\n            return {'success': False, 'error': str(e)}\n\n    @staticmethod\n    def execute(component_id, action, params=None):\n        \"\"\"Execute an action on a component\"\"\"\n        try:\n            if params is None:\n                params = {}\n\n            from js import postMessage\n            import uuid\n            request_id = str(uuid.uuid4())\n\n            # Convert Python dict to JS object using to_js, with proper nested conversion\n            message = to_js({\n                'type': 'desktop-api-request',\n                'requestId': request_id,\n                'method': 'execute_action',\n                'params': to_js({\n                    'componentId': component_id,\n                    'action': action,\n                    'params': to_js(params)\n                })\n            })\n\n            # Send request to main thread via postMessage\n            postMessage(message)\n\n            print(f\"Sent API request: {component_id}.{action}\")\n            return {'success': True, 'message': 'Request sent to main thread'}\n\n        except Exception as e:\n            print(f\"Error executing {component_id}.{action}: {e}\")\n            return {'success': False, 'error': str(e)}\n\n    @staticmethod\n    def subscribe_event(event_name, callback):\n        \"\"\"Subscribe to EventBus events\"\"\"\n        try:\n            proxy_callback = create_proxy(callback)\n\n            from js import postMessage\n            import uuid\n            request_id = str(uuid.uuid4())\n\n            # Store callback for later use\n            if not hasattr(DesktopAPILegacy, '_event_callbacks'):\n                DesktopAPILegacy._event_callbacks = {}\n            DesktopAPILegacy._event_callbacks[event_name] = proxy_callback\n\n            # Send subscription request via postMessage\n            message = to_js({\n                'type': 'desktop-api-request',\n                'requestId': request_id,\n                'method': 'subscribe_event',\n                'params': to_js({\n                    'eventName': event_name\n                })\n            })\n            postMessage(message)\n\n            def unsubscribe():\n                if hasattr(DesktopAPILegacy, '_event_callbacks') and event_name in DesktopAPILegacy._event_callbacks:\n                    del DesktopAPILegacy._event_callbacks[event_name]\n                    proxy_callback.destroy()\n                    # Could send unsubscribe message here if needed\n\n            return unsubscribe\n\n        except Exception as e:\n            print(f\"Error subscribing to event {event_name}: {e}\")\n            return lambda: None\n",
  "events.py": "# ----------------------------------------------------\n# Events System\n# ----------------------------------------------------\n\nclass Events:\n    \"\"\"EventBus integration\"\"\"\n\n    @staticmethod\n    async def emit(event_name, data=None):\n        \"\"\"Emit an event to the desktop EventBus\"\"\"\n        try:\n            # Safely get Comlink bridge from globalThis\n            api_comlink = getattr(js.globalThis, 'desktop_api_comlink', None)\n            if api_comlink is None:\n                raise Exception(\"Comlink API bridge not available\")\n\n            # Convert data for JS\n            js_data = to_js(data) if data is not None else None\n\n            # Direct call to emit\n            await api_comlink.emitEvent(event_name, js_data)\n            return {'success': True, 'message': f'Event {event_name} emitted'}\n        except Exception as e:\n            print(f\"Error emitting event {event_name} via Comlink: {e}\")\n            # Fallback to postMessage (will be available from combined script)\n            return {'success': False, 'error': 'Comlink bridge not available'}\n\n    @staticmethod\n    async def subscribe(event_name, callback):\n        \"\"\"Subscribe to desktop events\"\"\"\n        # Will reference DesktopAPI when combined\n        return None\n\n\nclass EventsLegacy:\n    \"\"\"EventBus integration via postMessage\"\"\"\n\n    @staticmethod\n    def emit(event_name, data=None):\n        \"\"\"Emit an event to the desktop EventBus\"\"\"\n        try:\n            from js import postMessage\n            import uuid\n            request_id = str(uuid.uuid4())\n\n            message = to_js({\n                'type': 'desktop-api-request',\n                'requestId': request_id,\n                'method': 'emit_event',\n                'params': to_js({\n                    'eventName': event_name,\n                    'data': to_js(data) if data is not None else None\n                })\n            })\n            postMessage(message)\n\n            return {'success': True, 'message': f'Event {event_name} emitted'}\n\n        except Exception as e:\n            print(f\"Error emitting event {event_name}: {e}\")\n            return {'success': False, 'error': str(e)}\n\n    @staticmethod\n    def subscribe(event_name, callback):\n        \"\"\"Subscribe to desktop events\"\"\"\n        # Will reference DesktopAPILegacy when combined\n        return lambda: None\n",
  "mcp_protocol.py": "# ----------------------------------------------------\n# MCP Protocol Layer (JSON-RPC 2.0 Interface)\n# ----------------------------------------------------\n\nclass MCPProtocol:\n    \"\"\"Python interface to MCP protocol (JSON-RPC 2.0)\"\"\"\n\n    @staticmethod\n    async def send(message):\n        \"\"\"Send a raw MCP protocol message (JSON-RPC 2.0 format)\"\"\"\n        try:\n            # Ensure message is properly formatted as JSON-RPC 2.0\n            if not isinstance(message, dict):\n                raise ValueError(\"Message must be a dictionary\")\n\n            if not message.get('jsonrpc') == '2.0':\n                message['jsonrpc'] = '2.0'\n\n            if 'id' not in message:\n                message['id'] = str(uuid.uuid4())\n\n            # Convert to JS object - use JSON serialization to avoid JsProxy issues\n            import json\n            js_message_json = json.dumps(message)\n\n            # Debug: Log the message being sent\n            print(f\"Sending MCP message: {message}\")\n            print(f\"JSON message: {js_message_json}\")\n\n            # Forward to MCP handler in worker via the exposed plugin instance\n            # Access the plugin instance from pyodide globals (use js.globalThis, not Python globals())\n            plugin_instance = js.globalThis._pyodide_plugin_instance\n            if plugin_instance is None:\n                raise Exception(\"Pyodide plugin instance not available\")\n\n            # Pass the JSON string instead of JsProxy\n            result = await plugin_instance.handleMCPProtocolMessage(js_message_json)\n\n            # Extract the actual response from the PythonResult wrapper\n            if hasattr(result, 'success') and result.success and hasattr(result, 'result'):\n                return result.result.to_py() if hasattr(result.result, 'to_py') else result.result\n            elif hasattr(result, 'error'):\n                return {'jsonrpc': '2.0', 'error': {'code': -32603, 'message': result.error}, 'id': message.get('id')}\n            else:\n                return {'jsonrpc': '2.0', 'error': {'code': -32603, 'message': 'Internal error'}, 'id': message.get('id')}\n\n        except Exception as e:\n            print(f\"Error sending MCP message: {e}\")\n            return {'jsonrpc': '2.0', 'error': {'code': -32603, 'message': str(e)}, 'id': message.get('id')}\n\n    @staticmethod\n    async def tools_list():\n        \"\"\"Get list of available tools via MCP protocol\"\"\"\n        message = {\n            'jsonrpc': '2.0',\n            'method': 'tools/list',\n            'id': str(uuid.uuid4())\n        }\n        return await MCPProtocol.send(message)\n\n    @staticmethod\n    async def tools_call(tool_name, arguments=None):\n        \"\"\"Call a tool via MCP protocol\"\"\"\n        if arguments is None:\n            arguments = {}\n\n        message = {\n            'jsonrpc': '2.0',\n            'method': 'tools/call',\n            'params': {\n                'name': tool_name,\n                'arguments': arguments\n            },\n            'id': str(uuid.uuid4())\n        }\n        return await MCPProtocol.send(message)\n\n    @staticmethod\n    async def resources_list():\n        \"\"\"List available resources via MCP protocol\"\"\"\n        message = {\n            'jsonrpc': '2.0',\n            'method': 'resources/list',\n            'id': str(uuid.uuid4())\n        }\n        return await MCPProtocol.send(message)\n"
}